/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package edu.ucsd.crbs.segmenter.slice;

import edu.ucsd.crbs.segmenter.App;
import java.io.File;
import java.io.FileFilter;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.commons.io.filefilter.FileFileFilter;

/**
 * Daemon that looks for files with {@link Dm4SliceFile#DM4_EXTENSION} extension
 * and uses a converter to create tiled datasets suitable for Segmenter.
 *
 * @author churas
 */
public class Dm4SliceConverterDaemon implements SliceConverterDaemon {

    private static final Logger _log
            = Logger.getLogger(Dm4SliceConverterDaemon.class.getName());

    private Properties _props;
    private File _dirToWatch;
    private SliceConverter _sliceConverter;
    private boolean _shutdown = false;
    private File _secondYoungestFile = null;
    private String _destDir = null;
    private long _threadSleepMillis = 10000;

    /**
     * Constructor
     *
     * @param props Should be a {@link Properties} object generated by
     * {@link App#getPropertiesFromCommandLine(joptsimple.OptionSet)}
     * @param converter Used in {@link #run()} to convert
     * {@link Dm4SliceFile#DM4_EXTENSION} files to tiles
     * @throws NullPointerException if either {@link App#INPUT_IMAGE_ARG} or
     * {@link App#DIR_ARG} are <code>null</code> in <b>props</b> parameter.
     */
    public Dm4SliceConverterDaemon(Properties props, SliceConverter converter) {
        _props = props;

        if (_props == null) {
            throw new NullPointerException("props is null");
        }

        //need to set directory to watch,
        String inputImage = _props.getProperty(App.INPUT_IMAGE_ARG);
        if (inputImage == null) {
            throw new NullPointerException(App.INPUT_IMAGE_ARG
                    + " property is null");
        }
        _dirToWatch = new File(inputImage);

        //sets directory where output of conversion should be written
        _destDir = props.getProperty(App.ADJUSTED_INPUT_IMAGE_ARG);
        if (_destDir == null) {
            throw new NullPointerException(App.ADJUSTED_INPUT_IMAGE_ARG
                    + " property is null");
        }
        _sliceConverter = converter;
    }

    /**
     * Adjusts time this object sleeps when no data needs to be converted in
     * {@link #run()} method. If value less then 0 is passed in method will use
     * value of 0.
     *
     * @param timeMillisSeconds time in milliseconds
     *
     */
    public void setThreadSleepTime(long timeMillisSeconds) {

        _threadSleepMillis = timeMillisSeconds;
        if (_threadSleepMillis < 0) {
            _threadSleepMillis = 0;
        }
    }

    /**
     * Gets the directory where converted output will be stored
     *
     * @return String containing full path to base directory
     */
    @Override
    public String getDestinationDirectory() {
        return _destDir;
    }

    /**
     * Tells this object to exit when in the {@link #run()} method
     */
    @Override
    public void shutdown() {
        _log.log(Level.INFO, "Received shutdown notification");
        _shutdown = true;
    }

    /**
     * Converts second youngest {@link Dm4SliceFile#DM4_EXTENSION} file found in
     * input directory via {@link SliceConverter} set in constructor writing
     * output to directory under {@link #getDestinationDirectory()}
     *
     * Should be run under a new thread. This method loops indefinitely until
     * {@link #shutdown()} is invoked.
     */
    @Override
    public void run() {
        _log.log(Level.INFO, " Dm4SliceConverterDaemon, entering run loop...");
        while (_shutdown == false) {
            File dm4File = getSecondYoungestDm4File();
            
            if (dm4File == null) {
                threadSleep();
                continue;
            }
            
            if (_secondYoungestFile != null) {
                if (dm4File.getName().equals(_secondYoungestFile.getName())) {
                    _log.log(Level.INFO, "Dm4 file {0} has same name as"
                            + " second youngest file {1}, doing nothing",
                            new Object[]{dm4File.getName(),
                                _secondYoungestFile.getName()
                            });
                    threadSleep();
                    continue;
                }
                if (dm4File.lastModified()
                        < _secondYoungestFile.lastModified()) {
                    _log.log(Level.INFO, "Dm4 file {0} ({1}) is younger then"
                            + " second youngest file {2} ({3}),"
                            + " doing nothing",
                            new Object[]{dm4File.getName(),
                                dm4File.lastModified(),
                                _secondYoungestFile.getName(),
                                _secondYoungestFile.lastModified()
                            });
                    threadSleep();
                    continue;
                }
            }
            _secondYoungestFile = dm4File;
            _log.log(Level.INFO, "Found file to convert: "
                    + dm4File.getAbsolutePath());

            String dest = genDestinationPath(dm4File);
            try {
                _sliceConverter.convert(dm4File.getAbsolutePath(), dest);
            } catch (Exception ex) {
                _log.log(Level.WARNING, "Caught exception attempting to "
                        + "convert file: " + dm4File.getAbsolutePath()
                        + " to " + dest + " : " + ex.getMessage());
            }

            threadSleep();
        }
        _log.log(Level.INFO, "Shutting down...");
    }

    /**
     * Tells this to first {@link Thread#yield()} and then
     * {@link Thread#sleep(long)} for time set in
     * {@link #setThreadSleepTime(long)}
     */
    private void threadSleep() {
        _log.log(Level.INFO, "Sleeping " + _threadSleepMillis
                + " milliseconds.");
        Thread.yield();
        try {
            Thread.sleep(_threadSleepMillis);
        } catch (InterruptedException ie) {
            // do nothing
            _log.log(Level.FINEST, "Received InterruptedException");
        }
    }

    /**
     * Builds the destination directory path which is
     * {@link #getDestinationDirectory() } / {@link  SliceDir#SLICE_PREFIX} /
     * <b>dm4File</b> {@link File#getName()}
     *
     * @param dm4File
     * @return
     */
    protected String genDestinationPath(File dm4File) {
        Dm4SliceFile sliceFile = new Dm4SliceFile(dm4File.getAbsolutePath());
        return _destDir + File.separator + SliceDir.SLICE_PREFIX
                + sliceFile.getSliceName();
    }

    /**
     * Gets 2nd youngest dm4 file in input directory as determined by checking
     * {@link File#lastModified()}. Only files ending in
     * {@link Dm4SliceFile#DM4_EXTENSION} are examined.
     *
     * @return File object for 2nd youngest dm4 file or null if none found.
     */
    protected File getSecondYoungestDm4File() {

        long youngestAge = -1;
        File youngestFile = null;
        File secondYoungest = null;

        File[] files = _dirToWatch.listFiles((FileFilter) FileFileFilter.FILE);
        for (int i = 0; i < files.length; i++) {
            if (!files[i].getName().endsWith(Dm4SliceFile.DM4_EXTENSION)) {
                continue;
            }
            _log.log(Level.FINEST, "Found dm4 file: " + files[i].getName());
            if (youngestAge == -1) {
                youngestAge = files[i].lastModified();
                youngestFile = files[i];
                _log.log(Level.FINEST, "Youngest: "
                        + youngestFile.getName());
                continue;
            }
            if (files[i].lastModified() > youngestAge) {
                _log.log(Level.FINE, "New 2nd youngest: "
                        + youngestFile.getName() + " replaces: "
                        + secondYoungest.getName());

                secondYoungest = youngestFile;
                youngestAge = files[i].lastModified();
                youngestFile = files[i];
            }
        }
        _log.log(Level.FINE, "2nd youngest: " + secondYoungest.getName());
        return secondYoungest;
    }
}
